package dataplane

import (
	"fmt"
	"math/rand"
	"net"
	"testing"
	"time"

	"github.com/golang/mock/gomock"
	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/stretchr/testify/assert"

	"github.com/scionproto/scion/go/lib/mocks/net/mock_net"
	"github.com/scionproto/scion/go/lib/snet"
	"github.com/scionproto/scion/go/lib/xtest"
)

func TestThreePathsEncryptionWithRandomData(t *testing.T) {
	fmt.Println("[Running Test]: privacyproxy_test.go->TestThreePathsEncryptionWithRandomData")
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	numPackets := 10
	random := rand.New(rand.NewSource(42))

	// Unbuffered channel guarantees that the frames won't be sent out
	// immediately, but only when waitFrames is called.
	frameChan := make(chan ([]byte))

	sess := createMockSession(ctrl, frameChan)

	addr := &snet.UDPAddr{
		IA: xtest.MustParseIA("1-ff00:0:300"),
		Host: &net.UDPAddr{
			IP:   net.IP{192, 168, 1, 1},
			Port: 80,
		},
	}

	mt := &MockTun{}
	w := newWorker(addr, 1, 2, mt, IngressMetrics{})

	// create a list of randomly generated gopackets and send them
	packets := make([]gopacket.Packet, numPackets)
	for i := 0; i < numPackets; i++ {
		packets[i] = generateRandomPayloadPacket(random)
		sess.Write(packets[i])
	}
	waitFramesProxyTest(t, frameChan, 37, numPackets, w)

	assert.Equal(t, numPackets, len(mt.packets))

	for i := 0; i < numPackets; i++ {
		if len(mt.packets) != 0 {
			assert.Equal(t, packets[i].Data(), mt.packets[i])
		}
	}

	sess.Close()
}

func createMockSession(ctrl *gomock.Controller, frameChan chan []byte) *Session {
	conn := mock_net.NewMockPacketConn(ctrl)
	conn.EXPECT().LocalAddr().Return(&net.UDPAddr{IP: net.IP{192, 168, 1, 1}}).AnyTimes()
	conn.EXPECT().WriteTo(gomock.Any(), gomock.Any()).DoAndReturn(
		func(f []byte, _ interface{}) (int, error) {
			frameChan <- f
			return 0, nil
		}).AnyTimes()

	sess := NewSession(22, net.UDPAddr{}, conn, nil, SessionMetrics{}, 0)

	sess.SetPaths([]snet.Path{
		createMockPath(ctrl, 600),
		createMockPath(ctrl, 601),
		createMockPath(ctrl, 602),
	})
	return sess
}

// Creates a a packet with a fixed IPv4 header and a random payload of random length.
func generateRandomPayloadPacket(r *rand.Rand) gopacket.Packet {
	payloadSize := r.Int()%32 + 32
	bytes := append([]byte{
		// IPv4 header.
		0x40, 0, 0, byte(20 + payloadSize), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	}, make([]byte, payloadSize)...)

	// set payload content of bytes to random generated bytes
	r.Read(bytes[20:])

	decodeOptions := gopacket.DecodeOptions{
		NoCopy: true,
		Lazy:   true,
	}
	pkt := gopacket.NewPacket(bytes, layers.LayerTypeIPv4, decodeOptions)
	return pkt
}

func waitFramesProxyTest(t *testing.T, frameChan chan []byte, payloadSize int, pktCount int, e *worker) {
Top:
	for {
		select {
		case frame := <-frameChan:
			fmt.Println("frame received")
			SendFrame(t, e, frame)
		case <-time.After(1500 * time.Millisecond):
			fmt.Println("----[Debug]: 1500ms timout while waiting for frames from network")
			break Top
		}
	}
}
